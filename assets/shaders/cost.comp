//
// Cost Computation Shader Program (1/1)
// -------------------------------------
// Compute the cost of each universe.
// TODO (penguinliong): Use buffer texture later.
//L
#version 450
precision mediump float;



//
// Invocation
// ----------
//  When jobs are dispatched to this shader, the workgroup sizes should be
//  specified as the following:
//    x = universe ID.
// in uvec3 gl_GlobalInvocationID;
//L



//
// Local Invocation
// ----------------
//  These values are specialized at runtime.
//    HALF of the width of universes;
layout(local_size_x=1, local_size_x_id=1) in;
//    HALF of the height of universes.
layout(local_size_y=1, local_size_y_id=2) in;
//    Reserved.
layout(local_size_z=1, local_size_z_id=3) in;
// Constant ID are started from 1 because some Nvidia driver have problem
// starting from 0.
//L



//
// Inputs
// ------
//  Real universe. Must have width and height powers of 2.
layout(r32f, binding=0) readonly
uniform image2D real_univ;
//  Simulated universes. Must have the same widths and heights as the real
//  universe.
layout(r32f, binding=1) readonly
uniform image2DArray sim_univs;
//  Temporary shared buffer for sum calculation. Should have length of
//  `(UNIV_WIDTH * UNIV_HEIGHT * NUNIV / 4)`.
layout(std430, binding=2) coherent
buffer sum_temp_buf {
  float[] sum_temp;
};
//L

//
// Output
// ------
//  Costs. Must have length `NUNIV`.
layout(std430, binding=3)
buffer costs_buf {
  float[] costs;
};
//L


//
// Push Constants
// --------------
layout(std430, push_constant) uniform DeformMeta {
  // Half extent of input universes, i.e. vec2(univ.width / 2, univ.height / 2).
  ivec2 HALF_UNIV_EXTENT;
  // The size in floats of a single input universe (layer).
  int HALF_UNIV_SIZE;
};



float block_diff(ivec2 pos, int univ) {
  int x = pos.x;
  int y = pos.y;
  vec4 real_val = vec4(
    imageLoad(real_univ, ivec2(x    , y    )).x,
    imageLoad(real_univ, ivec2(x + 1, y    )).x,
    imageLoad(real_univ, ivec2(x    , y + 1)).x,
    imageLoad(real_univ, ivec2(x + 1, y + 1)).x);
  vec4 sim_val = vec4(
    imageLoad(sim_univs, ivec3(x    , y    , univ)).x,
    imageLoad(sim_univs, ivec3(x + 1, y    , univ)).x,
    imageLoad(sim_univs, ivec3(x    , y + 1, univ)).x,
    imageLoad(sim_univs, ivec3(x + 1, y + 1, univ)).x);
  vec4 diff = abs(real_val - sim_val);
  diff.xy += diff.zw;
  return diff.x + diff.y;
}

void main() {
  int x = int(gl_LocalInvocationID.x);
  int y = int(gl_LocalInvocationID.y);
  // NOT THIS: int univ = int(gl_GlobalInvocationID.x);
  int univ = int(gl_WorkGroupID.x);

  int univ_offset = univ * HALF_UNIV_SIZE;
  int pos_offset = y * HALF_UNIV_EXTENT.x + x;
  int offset = univ_offset + pos_offset;

  // Sum up first step for all universes. Fill `sum_temp` with partial sums.
  sum_temp[offset] = block_diff(ivec2(x << 1, y << 1), univ);
  memoryBarrier();
  barrier();

  // Now `sum_temp` is filled with values. Its size for each universe remainder
  // is `HALF_UNIS_SIZE`.
  for (int s = int(HALF_UNIV_SIZE); s > 1;) {
    int half_s = s >> 1;
    // Keep the one in middle when `s` is an odd number.
    int adjusted_half_s = half_s + (s & 1);
    if (pos_offset < half_s) {
      sum_temp[offset] += sum_temp[offset + adjusted_half_s];
      s = adjusted_half_s;
      memoryBarrier();
      barrier();
    } else {
      return;
    }
  }

  costs[univ] = sum_temp[univ_offset];
}
