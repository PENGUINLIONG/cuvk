//
// Cost Computation Shader Program (1/1)
// -------------------------------------
// Compute the cost of each universe.
//L
#version 450
precision mediump float;



//
// Invocation
// ----------
//  When jobs are dispatched to this shader, the workgroup sizes should be
//  specified as the following:
//    x = x index from 0 to HALF of the universe width;
//    y = y index from 0 to HALF of the universe height;
//    z = universe ID.
// in uvec3 gl_GlobalInvocationID;
//L



//
// Inputs
// ------
//  Real universe. Must have width and height powers of 2.
layout(r32f, binding=0) readonly
uniform image2D real_univ;
//  Simulated universes. Must have the same widths and heights as the real
//  universe.
layout(r32f, binding=1) readonly
uniform image2DArray sim_univs;
//  Temporary shared buffer for sum calculation. Should have length of
//  `(UNIV_WIDTH * UNIV_HEIGHT * NUNIV / 4)`.
layout(std430, binding=2)
buffer sum_temp_buf {
  float[] sum_temp;
};
//L

//
// Output
// ------
//  Costs. Must have length `NUNIV`.
layout(std430, binding=3)
buffer costs_buf {
  float[] costs;
};
//L


//
// Push Constants
// --------------
layout(std430, push_constant) uniform DeformMeta {
  // Half extent of input universes, i.e. vec2(univ.width / 2, univ.height / 2).
  uvec2 HALF_UNIV_EXTENT;
  // The size in floats of a single input universe (layer).
  uint HALF_UNIV_SIZE;
};



float block_diff(ivec2 pos, int univ) {
  int x = pos.x;
  int y = pos.y;
  vec4 real_val = vec4(
    imageLoad(real_univ, ivec2(x    , y    )).x,
    imageLoad(real_univ, ivec2(x + 1, y    )).x,
    imageLoad(real_univ, ivec2(x    , y + 1)).x,
    imageLoad(real_univ, ivec2(x + 1, y + 1)).x);
  vec4 sim_val = vec4(
    imageLoad(sim_univs, ivec3(x    , y    , univ)).x,
    imageLoad(sim_univs, ivec3(x + 1, y    , univ)).x,
    imageLoad(sim_univs, ivec3(x    , y + 1, univ)).x,
    imageLoad(sim_univs, ivec3(x + 1, y + 1, univ)).x);
  vec4 diff = abs(real_val - sim_val);
  diff.xy += diff.zw;
  return diff.x + diff.y;
}

void main() {
  int x = int(gl_GlobalInvocationID.x);
  int y = int(gl_GlobalInvocationID.y);
  int univ = int(gl_GlobalInvocationID.z);

  int univ_offset = int(univ * HALF_UNIV_SIZE);
  int pos_offset = int(y * HALF_UNIV_EXTENT.x) + x;
  int offset = univ_offset + pos_offset;

  // Sum up first step for all universes.
  sum_temp[offset] = block_diff(ivec2(x * 2, y * 2), univ);
  barrier();

  // Now `sum_temp` is filled with values. Its size for each universe is
  // `HALF_UNIS_SIZE`.
  int s = int(HALF_UNIV_SIZE);
  while (s > 1) {
    int half_s = s / 2;
    if (pos_offset < half_s) {
      sum_temp[offset] += sum_temp[offset + half_s];
      s = half_s;
    } else if (pos_offset == half_s && (s & 1) == 1) {
      // When the size is an odd number, the extra one should be preserved.
      sum_temp[offset] = sum_temp[offset + half_s];
      s = half_s + 1;
    } else {
      // Thread is finished.
      return;
    }
    barrier();
  }

  costs[univ] = sum_temp[univ_offset];
}
